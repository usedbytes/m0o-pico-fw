;
; Copyright (c) 2021 Brian Starkey <stark3y@gmail.com>
;
; SPDX-License-Identifier: BSD-3-Clause
;

.define PUBLIC PIN_OFFS_D0       0
.define PUBLIC PIN_OFFS_CLK_INH  1
.define PUBLIC PIN_OFFS_VSYNC    2
.define PUBLIC PIN_OFFS_HREF     3
.define PUBLIC PIN_OFFS_PXCLK    4
.define PUBLIC GPIO_XCLK         21

.program camera_frame

.wrap_target
irq wait 0          ; Synchronise with processor
pull
out Y, 32
pull

wait 1 gpio 2       ; Wait for VSYNC to go high

loop_line:
mov X, OSR
wait 1 gpio 3 [2]   ; Wait for HSYNC to go high

loop_pixel:
wait 0 gpio 4        ; Wait for PXCLK to go low
wait 1 gpio 4        ; Wait for PXCLK to go high
in PINS 8           ; Grab a byte of data
jmp x-- loop_pixel

wait 0 gpio 3       ; Wait for HSYNC to go high
jmp y-- loop_line
.wrap

% c-sdk {
static inline void camera_frame_program_init(PIO pio, uint sm, uint offset, uint data_base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, data_base_pin, 8, false);
    pio_sm_set_consecutive_pindirs(pio, sm, 2, 3, false);
    for (uint i = 2; i < 2 + 3 + 8; i++) {
        pio_gpio_init(pio, i);
    }

    pio_sm_config c = camera_frame_program_get_default_config(offset);
    sm_config_set_in_pins(&c, data_base_pin);
    sm_config_set_in_shift(&c, true, true, 32);
    sm_config_set_out_shift(&c, true, false, 0);
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}

static inline void camera_wait_for_eof(PIO pio)
{
    while (!pio_interrupt_get(pio, 0));
}

static inline void camera_do_frame(PIO pio, uint sm, uint32_t width, uint32_t height)
{
    camera_wait_for_eof(pio);
    pio_sm_put_blocking(pio, sm, height - 1);
    pio_sm_put_blocking(pio, sm, width - 1);
    pio_interrupt_clear(pio, 0);
}
%}

.program camera_shiftreg

.side_set 1 opt

.wrap_target
pull
out Y, 32
wait 1 pin PIN_OFFS_HREF [2]  side 0x1 ; Wait for HREF to go high, side set CLK_INH

loop_pixel:
wait 1 pin PIN_OFFS_PXCLK       ; Wait for PXCLK to go high
wait 1 gpio GPIO_XCLK           ; Wait for CLK to go high
set X 7
loop_bit:
	wait 0 gpio GPIO_XCLK side 0x0  ; Wait for CLK to go low, clear CLK_INH
	wait 1 gpio GPIO_XCLK           ; Wait for CLK to go high
	in PINS 1                       ; Grab a bit of data
	jmp x-- loop_bit
wait 0 pin PIN_OFFS_PXCLK side 0x1  ; Wait for PXCLK to go low, set CLK_INH
jmp y-- loop_pixel
wait 0 pin PIN_OFFS_HREF        ; Wait for HREF to go low
.wrap

% c-sdk {
static inline void camera_shiftreg_program_init(PIO pio, uint sm, uint offset, uint base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK_INH, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }

    pio_sm_config c = camera_shiftreg_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_in_shift(&c, true, true, 32);
    sm_config_set_out_shift(&c, true, false, 0);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}
%}

.program camera_shift_byte
.side_set 1 opt

.wrap_target
set X 7                                 ; Load the bit counter
wait 1 irq 0                            ; Wait to be triggered
wait 1 pin PIN_OFFS_PXCLK side 0x1      ; Wait for PXCLK to go high, set CLK_INH
wait 1 gpio GPIO_XCLK                   ; Wait for CLK to go high (before clearing INH)

loop_bit:
wait 0 gpio GPIO_XCLK side 0x0          ; Wait for CLK to go low, clear CLK_INH
wait 1 gpio GPIO_XCLK                   ; Wait for CLK to go high
in PINS 1                               ; Grab a bit of data
jmp x-- loop_bit

wait 0 pin PIN_OFFS_PXCLK side 0x1      ; Wait for PXCLK to go low, set CLK_INH
.wrap

% c-sdk {
static inline void camera_shift_byte_program_init(PIO pio, uint sm, uint offset, uint base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK_INH, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }

    pio_sm_config c = camera_shift_byte_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_in_shift(&c, true, true, 32);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}
%}

.program camera_frame_oneplane
.side_set 1 opt

.wrap_target
pull                                   ; Pull number of lines (note: used for synchronisation)
out Y, 32                              ; Store number of lines in Y
pull                                   ; Pull "pixels" per line. Keep this in OSR to reload X each line

wait 1 pin PIN_OFFS_VSYNC side 0x1     ; Wait for start of frame, set initial CLK_INH

loop_line:
mov X, OSR                             ; Store number of "pixels" in X
wait 1 pin PIN_OFFS_HREF [2]  side 0x1 ; Wait for start of line

loop_pixel:
irq wait 0                             ; Trigger the "pixel" SM, unblock when it starts
jmp x-- loop_pixel

wait 0 pin PIN_OFFS_HREF               ; Wait for end of line
jmp y-- loop_line
.wrap

% c-sdk {
static inline void camera_frame_oneplane_program_init(PIO pio, uint sm, uint offset, uint base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK_INH, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }

    pio_sm_config c = camera_frame_oneplane_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_out_shift(&c, true, false, 0);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}
%}
