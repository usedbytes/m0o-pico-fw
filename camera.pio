;
; Copyright (c) 2021 Brian Starkey <stark3y@gmail.com>
;
; SPDX-License-Identifier: BSD-3-Clause
;

.define PUBLIC PIN_OFFS_D0       0
.define PUBLIC PIN_OFFS_CLK_INH  1
.define PUBLIC PIN_OFFS_VSYNC    2
.define PUBLIC PIN_OFFS_HREF     3
.define PUBLIC PIN_OFFS_PXCLK    4
.define PUBLIC GPIO_XCLK         21

.define BYTE_IRQ_BASE            4

.program camera_shift_byte
.side_set 1 opt

.wrap_target
set X 7                                 ; Load the bit counter
wait 1 irq 4 rel                        ; Wait to be triggered - waits for IRQ 4 + SM number
wait 1 pin PIN_OFFS_PXCLK side 0x1      ; Wait for PXCLK to go high, set CLK_INH
wait 1 gpio GPIO_XCLK                   ; Wait for CLK to go high (before clearing INH)

loop_bit:
wait 0 gpio GPIO_XCLK side 0x0          ; Wait for CLK to go low, clear CLK_INH
wait 1 gpio GPIO_XCLK                   ; Wait for CLK to go high
in PINS 1                               ; Grab a bit of data
jmp x-- loop_bit

wait 0 pin PIN_OFFS_PXCLK side 0x1      ; Wait for PXCLK to go low, set CLK_INH
.wrap

% c-sdk {
static inline void camera_shift_byte_program_init(PIO pio, uint sm, uint offset, uint base_pin, uint bpp)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK_INH, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }

    pio_sm_config c = camera_shift_byte_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_in_shift(&c, true, true, bpp);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}

static inline pio_sm_config camera_pio_get_pixel_sm_config(PIO pio, uint sm, uint offset, uint base_pin, uint bpp)
{
    pio_sm_config c = camera_shift_byte_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_in_shift(&c, true, true, bpp);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);

    return c;
}
%}

.program camera_frame_oneplane
.side_set 1 opt

.wrap_target
pull                                   ; Pull number of lines (note: used for synchronisation)
out Y, 32                              ; Store number of lines in Y
pull                                   ; Pull "pixels" per line. Keep this in OSR to reload X each line

wait 1 pin PIN_OFFS_VSYNC side 0x1     ; Wait for start of frame, set initial CLK_INH

loop_line:
mov X, OSR                             ; Store number of pixels in X
wait 1 pin PIN_OFFS_HREF [2]  side 0x1 ; Wait for start of line

; The pixel loop body can be patched for different pixel formats / plane
; layouts. Up to 4 bytes per pixel.
; For a format with less than 4 bytes per pixel, some of these commands will
; be patched to NOPs. For multi-plane formats, other SMs will be triggered
; as appropriate
; By default, this is set up for 4-bytes per pixel, in a single plane,
; handled by SM1
public loop_pixel:
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 0)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 1)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 2)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 3)
jmp x-- loop_pixel

wait 0 pin PIN_OFFS_HREF               ; Wait for end of line
jmp y-- loop_line
.wrap

% c-sdk {
static inline void camera_pio_init_gpios(PIO pio, uint sm, uint base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK_INH, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }
}

static inline void camera_frame_oneplane_program_init(PIO pio, uint sm, uint offset, uint base_pin)
{
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin, 5, false);
    pio_sm_set_consecutive_pindirs(pio, sm, base_pin + PIN_OFFS_CLK_INH, 1, true);
    for (uint i = 0; i < 5; i++) {
        pio_gpio_init(pio, i + base_pin);
    }

    pio_sm_config c = camera_frame_oneplane_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_out_shift(&c, true, false, 0);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);
    pio_sm_init(pio, sm, offset, &c);

    pio_sm_set_enabled(pio, sm, true);
}

static inline pio_sm_config camera_pio_get_frame_sm_config(PIO pio, uint sm, uint offset, uint base_pin)
{
    pio_sm_config c = camera_frame_oneplane_program_get_default_config(offset);
    sm_config_set_in_pins(&c, base_pin);
    sm_config_set_out_shift(&c, true, false, 0);
    sm_config_set_sideset_pins(&c, base_pin + PIN_OFFS_CLK_INH);

    return c;
}
%}

.program pixel_loop_yuyv
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 0)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 1)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 2)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 3)

.program pixel_loop_rgb565
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 0)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 1)
nop
nop

.program pixel_loop_nv16
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 0)
irq wait (BYTE_IRQ_BASE + 2)           ; Trigger byte SM2 (byte 1)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 2)
irq wait (BYTE_IRQ_BASE + 2)           ; Trigger byte SM2 (byte 3)

.program pixel_loop_yu16
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 0)
irq wait (BYTE_IRQ_BASE + 2)           ; Trigger byte SM2 (byte 1)
irq wait (BYTE_IRQ_BASE + 1)           ; Trigger byte SM1 (byte 2)
irq wait (BYTE_IRQ_BASE + 3)           ; Trigger byte SM3 (byte 3)
